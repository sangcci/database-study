들어가기에 앞서..

> 내부 구조 및 동작 원리를 파악하는 것이 중요한 이유
> 1. 어디가 잘못되었는지 파악이 가능하다
> 2. 성능 등을 개선하고 싶을 때 더 좋은 힌트를 얻을 수 있다.

> 스토리지 엔진의 개념
> 각 단위 작업을 누가 처리하는지 (MySQL 엔진 or 스토리지 엔진)
> "하나의 쿼리 작업은 여러 하위 작업으로 나뉘는데, 각 하위 작업이 MySQL 엔진 영역에서 처리되는지 아니면 스토리지 엔진 영역에서 처리되는지 구분할 줄 알아야 한다."

---

# MySQL 서버의 전체 구조
![image](https://github.com/user-attachments/assets/bdc3adf8-d3db-405b-83d0-192b2507eeac)


---

# MySQL 엔진 + innodb 엔진 스레딩 모델
![image](https://github.com/user-attachments/assets/234c9282-52f0-4475-8b67-d86f542a740c)


> 일꾼들

### 포그라운드 스레드(클라이언트 스레드)

- 커넥션 연결 <--> 스레드 캐시
- select 캐시 & 버퍼 -> 없으면 디스크 데이터, 인덱스 파일
### 백그라운드 스레드

- innodb는 기록 작업은 백그라운드 -> innodb 버퍼 풀의 데이터를 디스크에 기록하는 스레드 -> 지연 일괄 처리
- 데이터를 버퍼로 읽어오는 스레드
- 로그를 디스크로 기록하는 스레드
- 인서트 버퍼를 병합하는 스레드
- 잠금이나 데드락을 모니터링하는 스레드

---

# MySQL 엔진 + innodb 엔진의 메모리 사용 및 할당 구조
![image](https://github.com/user-attachments/assets/2d5fdfe5-17af-4daa-b8db-6952f767bf32)

> 공장 혹은 일꾼들이 들고다니는 데이터

### 글로벌 메모리 영역

모든 스레드(일꾼)들에 의해 공유
- 테이블 캐시
- innodb 버퍼 풀
- innodb 어댑티브 해시 인덱스
- innodb 리두 로그 버퍼
### 로컬 메모리 영역

일꾼마다 고유의 데이터. 절대 공유되지 않음.
- 정렬 버퍼(쿼리 분석 후 필요할 때만 공간 할당)
- 조인 버퍼(쿼리 분석 후 필요할 때만 공간 할당)
- 바이너리 로그 캐시
- 네트워크 버퍼(커넥션 열려있는 동안 항상 할당)
- 결과 버퍼(커넥션 열려있는 동안 항상 할당)


![image](https://github.com/user-attachments/assets/33cd2b0e-ebf0-46c6-9fd4-5368dcdb0b07)

### 플러그인 스토리지 엔진

마치 JPA와 Hibernate와의 관계처럼, 여러 개 플러그인을 사용할 수 있도록 MySQL 서버에서 제공.
MySQL서버에서 콘센트 포트를 제공하고, 타 개발자가 구현한 콘센트를 넣는 거?

### 핸들러(사실 상 스토리지 엔진)

스토리지 엔진이라는 자동차에 MySQL 엔진이 탑승한다. MySQL 엔진은 자동차를 운전하기 위해 핸들을 조정한다. 핸들(러)을 조정함으로써 자동차가 굴러간다!
> MySQL 엔진이 각 스토리지 엔진에게 데이터를 읽어오거나 저장하도록 명령하려면 반드시 핸들러를 통해야 한다

`Handler_` 상태 변수: MySQL 엔진이 각 스토리지 엔진(자동차)에게 보낸 명령의 횟수(핸들 돌린 횟수)를 의미하는 변수


MyISAM이나 InnoDB나 MySQL 처리 내용은 대부분 동일하다.
이들은 모두 스토리지 엔진 플러그인 1개로 제공되기 때문에 단순히 `데이터 1개 레코드 읽기/쓰기 처리 방식`만이 차이가 있을 뿐, 실질적인 `GROUP BY`,`ORDER BY` 등 복잡한 처리는 MySQL 엔진 중 '쿼리 실행기'에서 처리한다.

---

# 쿼리 실행 구조
![image](https://github.com/user-attachments/assets/6e370460-141b-4855-aeeb-0ea1b6cee95d)


1. 쿼리 파서
쿼리 문장 -> 토큰(최소 단위의 어휘 혹은 기호) -> 토큰들 모여서 트리 형태 구조
문법을 걸러줌

2. 전처리기
트리를 분석해서 구조적 문제 찾아냄
객체 존재 여부, 접근 권한 등을 확인
존재 X, 권한 상 사용 불가일 경우 걸러짐

3. 옵티마이저
사실상 두뇌 역할.
쿼리를 저렴한 비용 + 가장 빠르게 처리하는 방법을 찾아서 결정
어떻게 하면 더 나은 선택을 유도할 수 있는지가 개발자의 관건

4. 실행 엔진
옵티마이저: 회사 경영진
실행 엔진: 중간 관리자
핸들러: 각 업무의 실무자

```
0. 옵티마이저가 GROUP BY를 처리하기 위해 임시 테이블 사용 결정 -> 실행 엔진에게 실행 계획 넘김
1. 실행 엔진이 핸들러에게 임시 테이블을 만들라고 요청
2. 다시 실행 엔진은 WHERE 절에 일치하는 레코드를 읽어오라고 핸들러에게 요청
3. 읽어온 레코드들을 1번에서 준비한 임시 테이블로 저장하라고 다시 핸들러에게 요청
4. 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어 오라고 핸들러에게 다시 요청
5. 최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘김
```
여기서는, 자세한 동작을 상상하지 말고 "요청해서 받은 결과를 토대로 또 다른 핸들러 요청을 하는구나" 정도로 이해.

핸들러
= 스토리지 엔진.

--- 

# 복제

replication
이는 다른 장에서 살펴본다.

--- 

# 쿼리 캐시; Query Cache

SQL 실행 결과를 메모리에 캐시 -> 동일 쿼리 실행 시 바로 캐시에서 반환.
매우 빠른 성능

but, 테이블 수정 시 -> 캐시에서도 해당 테이블 관련 데이터 삭제 -> 심각한 동시 처리 성능 저하.(삭제 다 되고 데이터 다시 디스크로부터 불러와야 됨. 그만큼의 시간 낭비)
이후 해당 이슈로 계속해서 많은 버그 발생

그래서 MySQL 8.0부터 MySQL 서버 기능에서 완전히 제외됨

여담으로, 위 쓰레드 구조 및 메모리 구조에 나오는 캐시들과 다름. 테이블 캐시는 그대로 존재.

---

# 스레드 풀

서버 프레임워크에서 동작하는 스레드 풀과 유사.
무료버전은 지원하지 않음.
> MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 해서 서버의 자원 소모를 줄이는 것이 목적

사실 스레드 풀이 눈에 띄는 성능 향상을 보여주는 경우는 드물다고 한다.

CPU가 동시 처리를 제일 잘 할 수 있는 쓰레드 수로 설정한다면, cpu의 프로세서 친화도 증가 및 불필요한 컨텍스트 스위치를 줄일 수 있다. - 정확히 어떤 컨텍스트 스위치인지는 모름. cpu의 친화도 증가가 무슨 의미인지 모름

CPU 코어의 갯수와 맞추는 것이 CPU 프로세서 친화도를 높이는 데 좋다고 한다.

---

# 트랜잭션 지원 메타데이터

전에는 테이블 구조 정보 등이 기록된 메타데이터를 파일로 별도 관리. 
파일 기반 메타데이터는 생성 및 변경 작업이 트랜잭션을 지원하지 않는 문제 발생 -> **일관되지 않는 데이터 문제**

MySQL 8.0부터는 아예 InnoDB의 테이블로 저장.
그래서 스키마 변경이 완전 성공 or 완전 실패로 정리됨.
시스템 테이블: MySQL 서버가 작동하는 데 기본적으로 필요한 테이블들의 묶음, 사용자 인증, 권한 등
데이터 딕셔너리 정보: 말 그대로.
`mysql` DB -> 시스템 테이블 + 데이터 딕셔너리
그래서 `mysql.ibd` 파일은 특히 주의해야 함.

데이터 딕셔너리 테이블은 우리한테 직접 보여주지 않음.(SELECT해도 안나옴)
대신, `infromation_schema` DB의 `TABLES`, `COLUMNS`라는 이름의 뷰로 제공

---

[Real MySQL 8.0 1권 4챕터](https://product.kyobobook.co.kr/detail/S000001766482)

[망나니개발자 블로그](https://mangkyu.tistory.com/299)

[MySQL InnoDB의 Adaptive Hash Index 활용 - kakao tech 블로그](https://tech.kakao.com/posts/319)

[Pagination in MySQL - Aaron Francis](https://planetscale.com/blog/mysql-pagination)

[Real MySQL 8.0 4장(2) - InnoDB의 구조 - 기록은 희미해지지 않는다.](https://neverfadeaway.tistory.com/61)
