# MySQL 엔진 아키텍처

## MySQL 전체 구조

> MySQL 서버는 **MySQL 엔진**과 **스토리지 엔진**으로 구분됨
> 

![스크린샷 2024-08-12 오후 6.43.45.png](https://github.com/user-attachments/assets/dc393642-4b40-431d-9c17-5df09fc15f5c)

### MySQL 엔진

> 요청된 SQL **쿼리 분석 혹은 최적화** 담당
> 
- **커넥션 핸들러** : 클라이언트로부터의 접속 및 쿼리 요청 처리
- **SQL 파서** : SQL 쿼리를 서버가 이해할 수 있도록 구문 분석
- **옵티마이저** : 쿼리의 최적화된 실행을 담당하며, 실행 계획을 수립
- **캐시** : 읽기가 자주 실행되는 데이터를 캐싱하여 쿼리 성능을 향상
- **버퍼** : 쓰기 작업이 필요한 데이터를 버퍼에 저장하고 한 번에 처리함으로써 디스크 I/O를 줄임 → DB 성능 향상

### 스토리지 엔진

> 실제 데이터를 **디스크 스토리지에 저장 혹은 데이터를 읽어 오는** 역할을 담당
> +) MySQL 엔진과 달리 여러 개 사용 가능
> 

### 핸들러 API

> MySQL 엔진의 쿼리 실행기에서 **스토리지 엔진에 쓰기 혹은 읽기 요청**을 할 때 사용하는 API
> 
- `Handler_` 변수
    - **MySQL 엔진이 각 스토리지 엔진에게 보낸 명령 횟수**
    

## MySQL 스레딩 구조

> MySQL은 **스레드 기반**으로 동작하며, **백그라운드 스레드**와 **포그라운드 스레드**로 구분됨
> 

### 포그라운드 스레드(클라이언트 스레드)

> 최소 MySQL 서버에 접속된 클라이언트 수만큼 존재하며, 각 **클라이언트가 요청한 SQL 쿼리를 처리**함
> 
- 커넥션 종료 시 담당하던 스레드는 **스레드 캐시로 복귀**하는데, 이미 일정 수 이상 대기 중인 스레드가 있으면 **스레드가 종료**됨
- 데이터 버퍼 혹은 캐시로부터 데이터를 가져오고, 없을 경우 디스크나 인덱스 파일에서 가져와서 처리

### 백그라운드 스레드

> MyISAM과 달리 InnoDB 스토리지 엔진에서는 다양한 역할을 수행
> 
- 인서트 버퍼(Insert Buffer) 병합
- 디스크에 로그 기록 → Log thread
- 버퍼 풀의 데이터를 디스크에 기록 → Write thread
- 데이터를 버퍼로 읽어 들임
- 잠금(lock)이나 데드락 모니터링

## 메모리 할당 및 사용 구조

> **글로벌 메모리 영역**과 **로컬 메모리 영역**으로 구분되며, 글로벌 메모리 영역은 운영체제가 할당
> 

### 글로벌 메모리 영역

> 클라이언트 스레드 수와 무관하게 하나만 할당되며, 모든 스레드가 공유함
> 
- 테이블 캐시
- InnoDB 버퍼 풀
- InnoDB 어댑티브 해시 인덱스
- InnoDB 리두(Redo) 로그 버퍼

### 로컬 메모리 영역 (세션 메모리 영역)

> **클라이언트 스레드가 쿼리를 처리**할 때 사용하는 영역으로, 각 스레드마다 독립적으로 할당
> 
- 정렬 버퍼 (Sort buffer)
- 조인 버퍼
- 바이너리 로그 캐시
- 네트워크 버퍼

## 플러그인 스토리지 엔진 모델

> 기본 스토리지 엔진 외에 **부가적인 기능을 제공하는 플러그인 엔진**을 설치해서 사용 가능
> 인증, 전문 검색 파서 커넥션 제어 등 다양한 플러그인 제공됨
> 

- 스토리지 엔진에 따라, 쿼리 작업의 각 하위 작업이 MySQL 엔진 영역에서 처리되는지, 혹은 스토리지 엔진 영역에서 처리되는지 **구분할 줄 아는 것이 중요**함

## 컴포넌트

> MySQL 8.0부터 기존 플러그인 아키텍처를 대체하기 위해 지원됨
> 
- 기존 플러그인 아키텍처의 단점
    - 각 플러그인 간의 통신 불가
    - MySQL 서버의 변수나 함수를 직접 호출해 보안상 이슈
    - 상호 의존 관계 설정 불가 → 초기화 어려움

## 쿼리 실행 구조

### 쿼리 파서

> 쿼리 문장을 **토큰(MySQL이 인식할 수 있는 최소 단위)로 분해해 트리 구조로 생성**
> SQL 문법 오류 시 이 단계에서 발견되고, 사용자에게 오류 메세지 전달
> 

### 전처리기

> 파서 트리를 기반으로 **쿼리 문장의 구조적 문제 확인**
> 테이블, 칼럼, 내장 함수 등의 이름을 실제 개체와 매핑해 객체의 존재 여부 및 접근 권한 확인
> 

### 옵티마이저

> 쿼리 문장을 **최소 비용으로 가장 빠르게 처리**할 수 있도록 결정
- DBMS의 실질적인 두뇌 역할

### 실행 엔진

> 옵티마이저의 **실행 계획에 따라 각 핸들러에게 요청** 및 최종 결과 사용자에게 전달

- 중간 관리자로 비유 가능

### 핸들러 (스토리지 엔진)

> 실행 엔진의 요청에 따라 **데이터를 디스크에 저장 및 읽어 오는 역할**
> 

## 쿼리 캐시

> SQL 실행 결과를 캐시해서 동일한 쿼리가 실행되면 해당 캐시의 결과 반환
> 동시 처리 성능 저하 및 버그로 인해 MySQL 8.0 이후 해당 기능 제거됨
> 
- 왜 성능 문제가 되었나
    - 테이블 데이터가 변경되면 캐시의 데이터에서 변경된 테이블 관련 데이터를 모두 삭제해야 함

## 스레드 풀

> MySQL 엔터프라이즈 에디션에서 제공하거나 Percona Server에 플러그인으로 구현되어 있음
> 내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄임. MySQL 서버의 CPU가 제한된 수의 스레드 처리에만 집중할 수 있도록 함. 따라서 **서버의 자원 소모를 줄이는 것이 목적**
> 
- 주의점
    - 스케줄링 과정에서 CPU 시간을 제대로 확보하지 못하면 오히려 성능이 나빠짐
    - `thread_pool_oversubscribe` 값이 너무 크면 스케줄링할 스레드가 많아져 스레드 풀이 비효율적으로 작동할 수 있음
- 스레드 그룹의 모든 스레드가 작업을 처리 중이라면
    - 타이머 스레드가 주기적으로 상태를 체크해 작업 스레드가 일정 시간 동안 처리를 끝내지 못하면, 새로운 스레드를 스레드 그룹에 추가함
    - 이때 `thread_pool_max_limit` 이상으로 스레드 생성 불가
- Percona Server는 선순위, 후순위 큐를 통해 **특정 트랜잭션이나 쿼리를 먼저 실행할 수 있는 기능** 제공
    - 이 기능으로 특정 트랜잭션이 점유하고 있는 잠금이 빨리 해제되고 경합을 낮춰 **처리 성능을 높일 수 있음**

## 트랜잭션 지원 메타데이터

> **메타데이터(데이터 딕셔너리)** : 테이블 구조 정보와 스토어드 프로그램(Stored Procedure?) 등의 정보
> 
- MySQL 5.7까지 이 정보를 파일로 관리
    - 트랜잭션을 지원하지 않아 테이블 생성 및 변경 도중 서버가 비정상 종료되면 일관성이 깨짐
- MySQL 8.0부터 InnoDB 테이블로 관리
    - 사용자 인증 및 권환 관련된 정보 : 시스템 테이블
    - 시스템 테이블 + 데이터 딕셔너리 : `mysql` 테이블
    - 트랜잭션을 지원하므로 스키마 변경 중 서버가 비정상 종료되어도 원자성을 보장

# InnoDB 스토리지 엔진 아키텍처

> 유일하게 레코드 기반 잠금을 제공하는 스토리지 엔진으로, **높은 동시성 처리가 가능하며 안정적**임
> 

![[MySQL 8.4 Reference Manual; InnoDB Architecture](https://dev.mysql.com/doc/refman/8.4/en/innodb-architecture.html)](https://dev.mysql.com/doc/refman/8.4/en/images/innodb-architecture-8-0.png)

## 프라이머리 키에 의한 클러스터링

> 일반적으로 모든 테이블은 PK 기반 클러스터링 인덱스가 생성됨
> 
- PK 값에 따라 디스크에 순서대로 저장
    - PK 기반 범위 스캔은 매우 빠르게 처리 가능
- 모든 세컨더리 인덱스 (사용자 지정 인덱스)는 PK 값을 논리 주소로 사용
- InnoDB에서만 지원 (MyISAM에서는 그저 유니크 제약을 가진 세컨더리 인덱스)

## 외래 키 지원

> 역시 InnoDB에서만 지원하는 기능으로, 자식 테이블의 컬럼이 부모 테이블 컬럼을 참조하는 값
> 
- MySQL에서는 자동으로 FK에 대한 인덱스 생성 (부모, 자식 테이블 모두)
    - 변경 시 부모 테이블이나 자식 테이블에 데이터 있는지 확인해야 함
        - 잠금이 여러 테이블로 전파되어 데드락 발생 가능성 존재
    - (자동으로 인덱스를 생성하지 않는 DBMS 존재; PostgreSQL)
- 수동으로 데이터를 저장하거나 스키마 변경 시 외래 키가 문제가 될 수 있음
    - `foreign_key_checks` OFF 설정 시 일시적으로 외래 키 체크 중지 가능
    - 중지해도 반드시 일관성을 맞춰준 후 다시 활성화 해야 함

## MVCC(Multi Version Concurrency Control)

[MySQL 8.4 Reference Manual; InnoDB MVCC](https://dev.mysql.com/doc/refman/8.4/en/innodb-multi-versioning.html)

> 레코드 레벨 트랜잭션 잠금을 지원하는 DBMS에서 지원하는 기능으로, **잠금을 사용하지 않는 일관된 읽기를 제공하는 것**이 주 목적
> 
- InnoDB는 언두(Undo) 로그를 통해 지원
- **Multi Version** : 하나의 레코드에 대해 여러 버전이 동시에 관리됨
    - 특정 트랜잭션 A에서 테이블 ‘aa’의 레코드 수정
    - 변경된 데이터가 InnoDB 버퍼에 저장되고, 원본 데이터는 Undo 로그에 저장
    - 디스크의 데이터 파일에는 시점에 따라 어느 데이터(버퍼 혹은 Undo 로그)가 반영되어 있을지 모름
    - 만약 A가 진행 중일 때, 다른 트랜잭션 B에서 ‘aa’의 변경된 레코드를 조회한다면?
        - 트랜잭션 격리 수준에 따라 다름 (MySQL 디폴트 레벨은 `REPEATABLE_READ`)
        - **`READ_COMMITED` 이상** : Undo 로그의 원본 데이터 조회
        - **`READ_UNCOMMITED`** : 버퍼 풀의 변경된 데이터
- 트랜잭션이 Commit 혹은 Rollback?
    - **Commit** : 버퍼 풀의 변경된 데이터를 영구적인 데이터로 저장
        - 언두 로그의 데이터는 필요로 하는 트랜잭션이 더이상 없을 때 삭제
        - 공식 문서에 의하면 `INSERT` 시의 언두 로그와 `UPDATE` 시의 로그가 구분되어, `INSERT` 는 트랜잭션 커밋 시 바로 삭제되고 `UPDATE` 는 다른 트랜잭션에서 필요하지 않을 때 삭제
    - **Rollback** : 언두 로그의 원본 데이터를 버퍼 풀로 복구, 언두 로그의 데이터 삭제

> 위와 같은 구조로 트랜잭션에서 변경되는 데이터를 관리하므로, 특정 트랜잭션이 오랫동안 종료되지 않으면 언두 로그에 데이터가 계속 쌓여서 문제가 될 수 있음
> 

## 잠금 없는 일관된 읽기 (Non-Locking Consistence Read)

> InnoDB는 MVCC를 통해 잠금 없이 읽기 작업을 수행함. 즉, **읽기 작업은 다른 트랜잭션의 잠금을 기다리지 않고 수행** 가능 (`SERIALIZABLE` 제외)
> 

## 자동 데드락 감지

> 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 **잠금 대기 목록을 그래프(Wait-for List)로 관리**
> 데드락 감지 스레드가 주기적으로 그래프를 검사해 교착 상태인 스레드를 강제 종료
> 
- 종료할 스레드 판별 기준
    - 언두 로그가 적은 트랜잭션이 롤백의 대상
- `innodb_table_locks` 활성화 시 MySQL 엔진의 테이블 잠금도 감지할 수 있어 웬만하면 활성화할 것
- 동시 처리 스레드가 매우 많아지거나, 각 트랜잭션마다 가진 잠금이 많으면 데드락 감지 스레드가 느려짐
    - 데드락 감지 스레드가 느려지면 쿼리를 처리하는 스레드가 작업을 진행하지 못해 서비스에 악영향
    - `innodb_deadlock_detect` 비활성화해 데드락 감지 스레드를 중지하고, `innodb_lock_wait_timeout` 을 활성화해 데드락 발생 시 타임아웃 설정해서 위 문제 해결 가능

## 자동화된 장애 복구

> InnoDB는 MySQL 서버가 시작될 때 **완료되지 못한 트랜잭션이나 디스크에 일부만 기록된 데이터 페이지를 복구**하는 작업을 자동으로 진행
> 
- 디스크나 서버 하드웨어 이슈로 자동 복구를 못한다면?
    - `innodb_force_recovery` 시스템 변수를 설정해서 MySQL 서버를 시작해야 함
        - InnoDB 로그 파일 손상 시 6으로 설정
        - InnoDB 테이블의 데이터 파일 손상 시 1로 설정
        - 그외의 경우 1~6 전부 하나씩 해봐야 함 (값이 클수록 심각한 상황이며 복구 가능성 낮아짐)
        - 복구 모드에서는 `SELECT` 외 쿼리 실행 불가
    - 그래도 안된다면 백업 후 데이터베이스를 다시 구축해야 함
        - 바이너리 로그를 통해 최대한 장애 시점까지 데이터 복구

## InnoDB 버퍼 풀

> 디스크의 **데이터 파일이나 인덱스 정보를 메모리에 캐싱**하는 공간으로, **쓰기 작업을 지연시켜 일괄 처리**할 수 있도록 하는 역할
> 

### 버퍼 풀의 크기 설정

> 운영체제와 각 클라이언트 스레드가 사용할 메모리를 충분히 고려해 설정해야 함. MySQL 5.7 이후부터 버퍼 풀의 크기를 동적으로 조절 가능
> 
- 커넥션이 많고 사용하는 테이블이 많을 경우 레코드 버퍼가 사용하는 메모리 공간이 커질 수 있음
    - 레코드 버퍼 : 각 클라이언트 세션에서 레코드를 읽고 쓸 때 사용하는 공간
- 운영체제 전체 메모리 공간 < 8GB : 50%를 InnoDB 버퍼 풀로 사용
- OS 메모리 공간 > 50GB : 15GB ~ 30GB 제외
- 버퍼 풀 크기를 줄이는 작업은 서비스에 미치는 영향이 매우 큼
- 버퍼 풀을 여러 개의 작은 버퍼 풀로 쪼개어 기존 내부 잠금 경합 문제를 개선

### 버퍼 풀의 구조

> 버퍼 풀을 페이지 크기의 조각으로 나누어 InnoDB 엔진이 데이터를 필요로 할 때 **해당 데이터 페이지를 읽어 각 조각에 저장**함. 이때 페이지를 관리하기 위해 **LRU 리스트, 플러시(Flush) 리스트, 프리(Free) 리스트**의 자료 구조로 관리함.
> 
- **LRU 리스트** : 엄밀히는 LRU와 MRU 리스트가 결합된 형태
    - LRU(Least Recently Used) : “Old 서브리스트”
    - MRU(Most Recently Used) : “New 서브리스트”
    - 디스크에서 한 번 읽어온 페이지는 최대한 오랫동안 버퍼 풀에 유지하기 위함 (디스크 읽기 최소화)
    - 데이터 페이지가 계속 사용될 수록 MRU 영역에 남고, 거의 사용 되지 않으면 LRU로 밀려나 결국 제거됨
- **Flush 리스트** : 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지(더티 페이지)의 변경 시점 기준 페이지를 관리
    - 데이터 변경 시 InnoDB는 변경 내용을 리두 로그(디스크)에 기록 + 버퍼 풀에도 반영
    - InnoDB는 체크포인트를 발생시켜 리두 로그와 데이터 페이지 상태를 동기화
- **Free 리스트** : 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지 목록
    - 사용자 쿼리가 새롭게 디스크의 데이터 페이지를 읽어 와야 할 때

### 버퍼 풀과 리두 로그

> 버퍼 풀은 데이터베이스 성능 향상을 위해 **데이터 캐시와 쓰기 버퍼링**을 목적으로 함. 이때 쓰기 버퍼링의 관점에서 **버퍼 풀은 리두 로그와 밀접한 관계**가 있음.
> 
- 리두 로그는 순환 고리 형태로 동작하므로, 과거 로그 엔트리는 다른 엔트리로 덮어 씌워질 수 있음
    - 재사용 가능한 공간, 재사용 불가능한 공간(활성 리두 로그)로 구분
    - 공간은 재사용되지만, 로그 포지션은 계속 증가 : LSN(Log Sequence Number)
    - 가장 최근 체크포인트 지점의 LSN이 활성 리두 로그 공간의 시작점
    - 가장 최근 체크포인트의 LSN - 마지막 리두 로그 엔트리의 LSN : 체크포인트 에이지(Checkpoint Age) = 활성 리두 로그 공간의 크기
- 체크포인트 발생 시, 체크포인트 LSN보다 작은 리두 로그 엔트리 관련 더티 페이지는 디스크로 동기화되어야 함

### 버퍼 풀 플러시(Buffer Pool Flush)

> 버퍼 풀에서 아직 디스크로 기록되지 않은 더티 페이지들을 성능상의 악영향 없이 디스크 동기화하기 위해 **백그라운드로 2가지 플러시 기능을 실행**
> 
- **플러시 리스트 플러시**
    - 플러시 리스트에서 오래전에 변경된 데이터 페이지를 순서대로 디스크에 동기화하는 작업
    - InnoDB에서 제공하는 시스템 변수를 통해 더티 페이지 비율, 더티 페이지 처리 스레드 수 등을 조절 가능
- **LRU 리스트 플러시**
    - LRU 리스트에서 사용 빈도가 낮은 데이터 페이지를 제거하는 작업

### 버퍼 풀 상태 백업 및 복구

> MySQL 5.6 이후 지원하는 버퍼 풀 덤프 및 적재 기능을 통해, **버퍼 풀의 상태를 백업하고 서버 재시작 시 복구 가능**
- 버퍼 풀에 데이터가 적재되어 있는 상태(워밍업)이 잘 되어 있으면 쿼리 처리 속도를 매우 높일 수 있음

### 버퍼 풀의 적재 내용 확인

> MySQL 8.0부터 `innodb_cached_indexes` 테이블에서 인덱스 별 적재된 데이터 페이지 수를 확인 가능
> 
- MySQL 5.6 이후 버전은 `innodb_buffer_page` 에서 제공 : 버퍼 풀이 큰 경우 테이블 조회가 상당히 큰 부하를 일으킴

## Double Write Buffer

> **더티 페이지를 디스크로 동기화할 때 일부만 기록**되는 문제가 발생할 수 있음. 이러한 현상을 파셜 페이지(Partial-page) 혹은 톤 페이지(Torn-page)라함.
> 이러한 문제를 해결하기 위한 방법이 **Double Write Buffer**
> 
- **Double Write**
    - 더티 페이지를 디스크에 기록하기 전에 시스템 테이블스페이스의 DoubleWrite 버퍼에 기록
    - 이후 각 더티 페이지를 파일의 적당한 위치에 랜덤으로 쓰기 실행
    - 서버 비정상 종료 후 재시작 시 DoubleWrite 버퍼와 데이터 파일의 페이지를 비교해 복구

## 언두(Undo) 로그

> DML로 변경 하기 이전의 데이터를 백업. **트랜잭션과 격리 수준을 보장**함.
> 

### 언두 로그 모니터링

- 언두 로그 데이터의 용도
    - 트랜잭션의 **롤백 대비**용
    - 트랜잭션 **격리 수준을 유지**하면서 **높은 동시성 제공**
- 주의점
    - 한 번 증가한 언두 로그 공간은 줄어들지 않음
    - 트랜잭션이 오래 활성화 되어 있어도 언두 로그 양이 급격히 증가할 가능성 존재

### 언두 테이블스페이스 관리

> 언두 로그가 저장되는 공간이 언두 테이블스페이스(Undo Tablespace)
> 
- MySQL 8.0 이후부터 테이블스페이스 외부의 별도 로그 파일에 기록되도록 개선
- 언두 테이블스페이스 구성
    - 1~128개의 롤백 세그먼트
    - 각 롤백 세그먼트에는 1개 이상의 언두 슬롯(Undo Slot)
    - 언두 슬롯이 부족하면 트랜잭션이 시작될 수 없어 적절히 설정해야 함

## 체인지 버퍼

> 레코드가 INSERT, UPDATE 되면 인덱스도 업데이트해야 함. 이때 **해당 인덱스 페이지**를 디스크에서 읽어 와야 한다면 **임시 공간에 저장**해 두는데, 이 공간을 **체인지 버퍼**라 함.
> 
- 중복 여부를 체크해야 하는 **유니크 인덱스는 체인지 버퍼 사용 불가**
- 임시 저장된 인덱스 레코드 조각은 **체인지 버퍼 머지 스레드**(Merge thread)라는 백그라운드 스레드에 의해 병합

## 리두 로그 및 로그 버퍼

> ACID 중 **D**과 밀접한 관계가 있음. MySQL 서버가 비정상 종료되었을 때 데이터 파일에 **기록되지 못한 데이터를 잃지 않게 하는 안전 장치**
> 
- 비정상 종료 시 발생할 수 있는 일관되지 않은 데이터
    - **커밋됐지만 디스크에 기록되지 않은 데이터** : 리두 로그의 데이터를 디스크에 복사
    - **롤백됐지만 디스크에 기록된 데이터** : 변경되기 전 데이터인 언두 로그의 데이터를 복사
        - 해당 변경이 커밋인지, 롤백인지, 트랜잭션 실행 중간이었는지 판단할 때 리두 로그 필요
- 리두 로그는 트랜잭션 커밋 시 즉시 디스크에 기록되도록 설정하는 것을 권장함
    - 그러나 실제로는 부하가 많이 발생할 수 있음
    - 리두 로그 동기화 주기를 시스템 변수로 설정 가능
- 로그 버퍼 : 리두 로그 버퍼링에 사용하는 공간

### 리두 로그 아카이빙

> MySQL 8.0 이후 지원하는 기능으로, 데이터 변경이 많아 **리두 로그가 덮어씌워져도 백업이 실패하지 않게** 하는 것이 목적
> 

### 리두 로그 활성화 및 비활성화

> MySQL은 기본적으로 비정상 종료 시 디스크에 기록되지 못한 트랜잭션을 복구하기 위해 리두 로그가 항상 활성화되어 있음. 따라서 **트랜잭션이 커밋되면 리두 로그는 항상 디스크에 기록**됨.
> 
- MySQL 8.0 이후 수동으로 리두 로그 활성화 및 비활성화 가능
    - 데이터를 복구하거나 대용량 데이터를 한 번에 적재할 때 비활성화해서 적재 시간을 단축할 수 있음
    - 비활성화 이후 꼭 다시 활성화해야 함

## 어댑티브 해시 인덱스

> InnoDB에서 **자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스**로, B-Tree 검색 시간을 줄여주기 위해 도입된 기능
> 
- 자주 조회하는 데이터 페이지의 키 값을 이용해 해시 인덱스 생성
- 필요할 때마다 해시 인덱스를 검색해 해당 페이지를 찾아감
- ‘인덱스 키 값’ - ‘데이터 페이지 주소’ 쌍으로 관리
- 버퍼 풀에 있는 데이터 페이지에 대해서만 관리
- MySQL 8.0부터 내부 잠금 경합을 줄이기 위해 파티션 기능을 제공
- 어댑티브 해시 인덱스를 **비활성화**하는 경우
    - 디스크 읽기가 많은 경우
    - 특정 패턴의 쿼리가 많은 경우(JOIN, LIKE 등)
    - 매우 큰 데이터가 있는 테이블에 대해 넓은 범위 조회
- 어댑티브 해시 인덱스가 **성능 향상에 도움** 되는 경우
    - 디스크 데이터가 버퍼 풀 크기와 비슷한 경우
    - 동등 조건 검색이 많은 경우
    - 쿼리가 일부 데이터에 집중되는 경우

## InnoDB, MyISAM, MEMORY

> MySQL 5.5 부터는 InnoDB가 기본 스토리지 엔진, MyISAM을 보조(전문 검색, 공간 좌표 검색 등)으로 사용함. MySQL 8.0부터 이를 InnoDB에서도 지원하면서 MyISAM은 사실상 필요 없음
- **InnoDB 말고 MyISAM, MEMORY를 선택해서 얻을 수 있는 이점이 없음**

# MyISAM 엔진 아키텍처

## 키 캐시

> InnoDB의 버퍼 풀과 비슷한 역할이지만, **인덱스만을 대상으로 작동**하고 인덱스의 **디스크 쓰기 작업에 대해서만 부분적으로 버퍼링** 역할
> 
- 일반적으로 키 캐시 히트율(Hit rate)을 99% 이상 유지할 것을 권장

## 운영체제의 캐시 및 버퍼

> MyISAM은 디스크의 I/O 작업에 대한 캐시 및 버퍼링 기능이 없어, 읽기 및 쓰기 작업은 **항상 운영체제의 디스크 읽기 혹은 쓰기 작업으로 요청**됨.
> 
- MyISAM 테이블을 주로 사용하면 운영체제가 사용하는 캐시 공간을 위한 메모리를 충분히 설정해야 함

## 데이터 파일과 프라이머리 키(인덱스) 구조

> InnoDB와 달리 클러스터링 없이 **힙(Heap) 공간에 데이터 파일이 저장**됨.
> 
- PK 값과 무관하게 INSERT 순으로 데이터 파일에 저장
- PK와 세컨더리 인덱스는 모두 ROWID라는 물리적 주솟값을 포인터로 가짐

# MySQL 로그 파일

> 로그 파일을 통해 MySQL의 상태나 부하를 일으키는 원인을 파악할 수 있음
> 

## 에러 로그 파일

> MySQL 실행 도중 발생하는 **에러나 경고 메세지가 출력되는 로그 파일**
> 
- 시작하는 과정과 관련된 정보성 및 에러 메세지
- 마지막 종료가 비정상 종료일 경우 나타나는 InnoDB 트랜잭션 복구 메세지
- 쿼리 처리 도중에 발생하는 문제에 대한 메세지
- 비정상 종료된 커넥션 메세지(Aborted connenction)
- InnoDB 모니터링 혹은 상태 조회 명령(ex. `SHOW ENGINE INNODB STATUS`) 결과 메세지
- MySQL 종료 메세지

## 제너럴 쿼리 로그 파일(General log)

> 서버에서 **실행되는 쿼리로 어떤 것들이 있는지 전체 목록을 검토**해야 할 때, 쿼리 로그를 활성화해 쿼리 로그 파일로 기록해 이 파일을 검토하면 됨
> 

## 슬로우 쿼리 로그

> 쿼리 튜닝 중 서비스 운영 중에 MySQL 전체적인 성능 저하를 검사하거나 정기적인 점검을 위해 튜닝하는 경우가 있는데, **슬로우 쿼리가 어떤 쿼리가 문제의 쿼리인지 판단**하는데 도움이 될 수 있음
> 
- 로그 파일에는 시스템 변수(`long_query_time`)에 설정한 시간 이상의 시간이 소요된 쿼리가 기록됨